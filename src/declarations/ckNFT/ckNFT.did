type Value__2 = 
 variant {
   Array: vec Value__2;
   Blob: blob;
   Int: int;
   Map: vec record {
              text;
              Value__2;
            };
   Nat: nat;
   Text: text;
 };
type Value = 
 variant {
   Array: vec Value;
   Blob: blob;
   Int: int;
   Map: vec record {
              text;
              Value;
            };
   Nat: nat;
   Text: text;
 };
type TransferResult = 
 variant {
   Err: TransferError;
   Ok: nat;
 };
type TransferFromResult = 
 variant {
   Err: TransferFromError;
   Ok: nat;
 };
type TransferFromError = 
 variant {
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InvalidRecipient;
   NonExistingTokenId;
   TooOld;
   Unauthorized;
 };
type TransferFromArg = 
 record {
   created_at_time: opt nat64;
   from: Account;
   memo: opt blob;
   spender_subaccount: opt blob;
   to: Account;
   token_id: nat;
 };
type TransferError = 
 variant {
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InvalidRecipient;
   NonExistingTokenId;
   TooOld;
   Unauthorized;
 };
type TransferArgs = 
 record {
   created_at_time: opt nat64;
   from_subaccount: opt blob;
   memo: opt blob;
   to: Account__1;
   token_id: nat;
 };
type TransactionRange = 
 record {
   length: nat;
   start: nat;
 };
type TokenApproval = 
 record {
   approval_info: ApprovalInfo;
   token_id: nat;
 };
type Tip = 
 record {
   hash_tree: blob;
   last_block_hash: blob;
   last_block_index: blob;
 };
type SupportedStandards = 
 vec record {
       name: text;
       url: text;
     };
type Subaccount = blob;
type Stats__1 = 
 record {
   cycleSettings:
    record {
      amountBasePerOwnerRequest: nat;
      amountPerBitcoinOwnerRequest: nat;
      amountPerETHCast: nat;
      amountPerEthOwnerRequest: nat;
      amountPerICOwnerRequest: nat;
      amountPerOtherOwnerRequest: nat;
      amountPerSolanaCast: nat;
      amountPerSolanaOwnerRequest: nat;
      cycleLedgerCanister: principal;
    };
   nativeChain: RemoteContractPointer;
   nextCastId: nat;
   orchestrator: principal;
   originalMinterMap: vec record {
                            nat;
                            Account__1;
                          };
   remoteOwnerMap: vec record {
                         nat;
                         RemoteOwner;
                       };
   "service": opt principal;
   solanaMintAddressMap: vec record {
                               nat;
                               RemoteAddressInfo;
                             };
 };
type Stats = 
 record {
   indexes:
    record {
      nft_to_owner_count: nat;
      owner_to_nfts_count: nat;
      recent_transactions_count: nat;
    };
   ledger_count: nat;
   ledger_info: LedgerInfoShared;
   nft_count: nat;
   owner: principal;
   supported_standards: SupportedStandards;
 };
type SolanaCluster = 
 variant {
   Custom: text;
   Devnet;
   Mainnet;
   Testnet;
 };
type SetNFTResult = 
 variant {
   Err: SetNFTError;
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   Ok: opt nat;
 };
type SetNFTError = 
 variant {
   CreatedInFuture: record {ledger_time: nat64;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   NonExistingTokenId;
   TokenExists;
   TooOld;
 };
type RevokeTokenApprovalResult = 
 variant {
   Err: RevokeTokenApprovalError;
   Ok: nat;
 };
type RevokeTokenApprovalError = 
 variant {
   ApprovalDoesNotExist;
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   NonExistingTokenId;
   TooOld;
   Unauthorized;
 };
type RevokeTokenApprovalArg = 
 record {
   created_at_time: opt nat64;
   from_subaccount: opt blob;
   memo: opt blob;
   spender: opt Account;
   token_id: nat;
 };
type RevokeCollectionApprovalResult = 
 variant {
   Err: RevokeCollectionApprovalError;
   Ok: nat;
 };
type RevokeCollectionApprovalError = 
 variant {
   ApprovalDoesNotExist;
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   TooOld;
   Unauthorized;
 };
type RevokeCollectionApprovalArg = 
 record {
   created_at_time: opt nat64;
   from_subaccount: opt blob;
   memo: opt blob;
   spender: opt Account;
 };
type Result_2 = 
 variant {
   err: text;
   ok: vec principal;
 };
type Result_1 = 
 variant {
   err: text;
   ok: bool;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type RequestRemoteOwnerRequest = 
 record {
   createdAtTime: opt nat;
   memo: opt blob;
   remoteNFTPointer: RemoteNFTPointer;
 };
type RemoteOwnershipUpdateError = 
 variant {
   FoundLocally: Account__1;
   GenericError: text;
   InsufficientAllowance: record {
                            nat;
                            nat;
                          };
   InsufficientBalance: record {
                          nat;
                          nat;
                        };
   InsufficientCycles: record {
                         nat;
                         nat;
                       };
   NotFound;
   QueryError: text;
   Unauthorized;
 };
type RemoteOwnerResult = 
 variant {
   Err: RemoteOwnershipUpdateError;
   Ok: RemoteOwner;
 };
type RemoteOwner = 
 variant {
   local: Account__1;
   remote:
    record {
      contract: RemoteContractPointer;
      owner: text;
      timestamp: nat;
    };
 };
type RemoteNFTPointer = 
 record {
   contract: text;
   network: Network;
   tokenId: nat;
 };
type RemoteContractPointer = 
 record {
   contract: text;
   network: Network;
 };
type RemoteAddressInfo = 
 record {
   altAddress: opt text;
   atRestAccount: opt Account__1;
   atRestDerivation: opt blob;
   contract: text;
   network: Network;
 };
type PropertyShared = 
 record {
   immutable: bool;
   name: text;
   value: CandyShared;
 };
type OwnerOfResponse = vec opt Account__1;
type OwnerOfRequest = vec nat;
type Network = 
 variant {
   Bitcoin: opt text;
   Ethereum: opt nat;
   IC: opt text;
   Other: ICRC16Map;
   Solana: opt SolanaCluster;
 };
type NFTMap = 
 vec record {
       text;
       Value;
     };
type MintNFTArgs = 
 record {
   created_at_time: opt nat64;
   memo: opt blob;
   metadata: NFTMap;
   owner: Account;
   spender: opt Account;
   token_id: nat;
 };
type LedgerInfoShared = 
 record {
   allow_transfers: bool;
   burn_account: opt Account;
   default_take_value: nat;
   description: opt text;
   logo: opt text;
   max_memo_size: nat;
   max_query_batch_size: nat;
   max_take_value: nat;
   max_update_batch_size: nat;
   name: opt text;
   permitted_drift: nat;
   supply_cap: opt nat;
   symbol: opt text;
   tx_window: nat;
 };
type IsApprovedArg = 
 record {
   from_subaccount: opt blob;
   spender: Account;
   token_id: nat;
 };
type InitArgs__3 = opt InitArgsList;
type InitArgs__2 = opt ArgList__1;
type InitArgs__1 = 
 record {
   archiveControllers: opt opt vec principal;
   archiveCycles: nat;
   archiveIndexType: IndexType;
   maxActiveRecords: nat;
   maxArchivePages: nat;
   maxRecordsInArchiveInstance: nat;
   maxRecordsToArchive: nat;
   settleToRecords: nat;
   supportedBlocks: vec BlockType;
 };
type InitArgsList = 
 record {
   nativeChain: RemoteContractPointer;
   "service": opt principal;
 };
type InitArgs = opt ArgList;
type IndexType = 
 variant {
   Managed;
   Stable;
   StableTyped;
 };
type ICRC16Map = 
 vec record {
       text;
       CandyShared;
     };
type GetTransactionsResult__1 = 
 record {
   archived_blocks: vec ArchivedTransactionResponse;
   blocks: vec record {
                 block: Value__2;
                 id: nat;
               };
   log_length: nat;
 };
type GetTransactionsFn = func (vec TransactionRange) ->
                          (GetTransactionsResult__1) query;
type GetArchivesResultItem = 
 record {
   canister_id: principal;
   end: nat;
   start: nat;
 };
type GetArchivesResult = vec GetArchivesResultItem;
type GetArchivesArgs = record {from: opt principal;};
type DataCertificate = 
 record {
   certificate: blob;
   hash_tree: blob;
 };
type CollectionApproval = 
 record {
   created_at_time: opt nat64;
   expires_at: opt nat64;
   from_subaccount: opt blob;
   memo: opt blob;
   spender: Account;
 };
type CastStatus = 
 variant {
   Completed: nat;
   Created;
   Error: CastError;
   RemoteFinalized: text;
   SubmittedToOrchestrator: record {
                              localCastId: nat;
                              remoteCastId: nat;
                            };
   SubmittingToOrchestrator: nat;
   WaitingOnContract: record {transaction: text;};
   WaitingOnMint: record {transaction: text;};
   WaitingOnTransfer: record {transaction: text;};
 };
type CastStateShared = 
 record {
   castId: nat;
   history: vec record {
                  CastStatus;
                  nat;
                };
   originalRequest: CastRequest;
   startTime: nat;
   status: CastStatus;
 };
type CastResult = 
 variant {
   Err: CastError;
   Ok: nat;
 };
type CastRequest = 
 record {
   created_at_time: opt nat;
   fromSubaccount: opt blob;
   gasLimit: opt nat;
   gasPrice: opt nat;
   maxPriorityFeePerGas: opt nat;
   memo: opt blob;
   remoteContract: RemoteContractPointer;
   targetOwner: text;
   tokenId: nat;
 };
type CastError = 
 variant {
   ContractNotVerified: variant {
                          NoConsensus;
                          TooManyRetries: nat;
                        };
   ExistingCast: nat;
   GenericError: text;
   InsufficientAllowance: record {
                            nat;
                            nat;
                          };
   InsufficientBalance: record {
                          nat;
                          nat;
                        };
   InsufficientCycles: record {
                         nat;
                         nat;
                       };
   InvalidContract;
   InvalidTransaction: text;
   MintNotVerified: variant {
                      NoConsensus;
                      TooManyRetries: nat;
                    };
   NetworkError: text;
   NoCkNFTCanister;
   NotFound;
   TransferNotVerified: variant {
                          NoConsensus;
                          TooManyRetries: nat;
                        };
   Unauthorized;
 };
type CastCostRequest = 
 record {
   contract: text;
   network: Network;
   tokenId: nat;
 };
type CandyShared = 
 variant {
   Array: vec CandyShared;
   Blob: blob;
   Bool: bool;
   Bytes: vec nat8;
   Class: vec PropertyShared;
   Float: float64;
   Floats: vec float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Ints: vec int;
   Map: vec record {
              text;
              CandyShared;
            };
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Nats: vec nat;
   Option: opt CandyShared;
   Principal: principal;
   Set: vec CandyShared;
   Text: text;
   ValueMap: vec record {
                   CandyShared;
                   CandyShared;
                 };
 };
type CKNFTActor = 
 service {
   assign: (token_id: nat, account: Account, remoteAddress: opt text,
    network: opt Network, derivationPath: opt blob, atRestAccount:
    opt Account__1, altAddress: opt text) -> (nat);
   /// Get list of authorized minters (owner-only)
   get_minters: () -> (Result_2) query;
   get_stats: () -> (record {
                       icrc7: Stats;
                       icrc99: Stats__1;
                     }) query;
   get_tip: () -> (Tip) query;
   icrc10_supported_standards: () -> (SupportedStandards) query;
   icrc37_approve_collection: (approvals: vec ApproveCollectionArg) ->
    (vec opt ApproveCollectionResult);
   icrc37_approve_tokens: (args: vec ApproveTokenArg) ->
    (vec opt ApproveTokenResult);
   icrc37_get_collection_approvals: (owner: Account, prev:
    opt CollectionApproval, take: opt nat) -> (vec CollectionApproval) query;
   icrc37_get_token_approvals: (token_ids: vec nat, prev: opt TokenApproval,
    take: opt nat) -> (vec TokenApproval) query;
   icrc37_is_approved: (args: vec IsApprovedArg) -> (vec bool) query;
   icrc37_max_approvals_per_token_or_collection: () -> (opt nat) query;
   icrc37_max_revoke_approvals: () -> (opt nat) query;
   icrc37_revoke_collection_approvals: (args:
    vec RevokeCollectionApprovalArg) ->
    (vec opt RevokeCollectionApprovalResult);
   icrc37_revoke_token_approvals: (args: vec RevokeTokenApprovalArg) ->
    (vec opt RevokeTokenApprovalResult);
   icrc37_transfer_from: (args: vec TransferFromArg) ->
    (vec opt TransferFromResult);
   icrc3_get_archives: (args: GetArchivesArgs) -> (GetArchivesResult) query;
   icrc3_get_blocks: (args: vec TransactionRange) ->
    (GetTransactionsResult__1) query;
   icrc3_get_tip_certificate: () -> (opt DataCertificate) query;
   icrc3_supported_block_types: () -> (vec BlockType) query;
   icrc7_atomic_batch_transfers: () -> (opt bool) query;
   icrc7_balance_of: (accounts: BalanceOfRequest) ->
    (BalanceOfResponse) query;
   icrc7_collection_metadata: () -> (vec record {
                                           text;
                                           Value;
                                         }) query;
   icrc7_default_take_value: () -> (opt nat) query;
   icrc7_description: () -> (opt text) query;
   icrc7_logo: () -> (opt text) query;
   icrc7_max_memo_size: () -> (opt nat) query;
   icrc7_max_query_batch_size: () -> (opt nat) query;
   icrc7_max_take_value: () -> (opt nat) query;
   icrc7_max_update_batch_size: () -> (opt nat) query;
   icrc7_name: () -> (text) query;
   icrc7_owner_of: (token_ids: OwnerOfRequest) -> (OwnerOfResponse) query;
   icrc7_permitted_drift: () -> (opt nat) query;
   icrc7_supply_cap: () -> (opt nat) query;
   icrc7_symbol: () -> (text) query;
   icrc7_token_metadata: (token_ids: vec nat) ->
    (vec opt vec record {
                   text;
                   Value;
                 }) query;
   icrc7_tokens: (prev: opt nat, take: opt nat) -> (vec nat) query;
   icrc7_tokens_of: (account: Account, prev: opt nat, take: opt nat) ->
    (vec nat) query;
   icrc7_total_supply: () -> (nat) query;
   icrc7_transfer: (args: vec TransferArgs) -> (vec opt TransferResult);
   icrc7_tx_window: () -> (opt nat) query;
   icrc99_burn_fund_address: (request: nat) -> (opt record {
                                                      text;
                                                      Network;
                                                    });
   icrc99_cast: (items: vec CastRequest, account: opt Account) ->
    (vec opt CastResult);
   icrc99_cast_cost: (request: CastCostRequest) -> (nat);
   /// Get the approval address that needs funding for re-export (cast) operations
   /// Returns the address where the NFT is held after burn-back to IC
   /// This address needs SOL to pay for the transfer transaction
   icrc99_cast_fund_address: (request: nat) -> (opt record {
                                                      text;
                                                      Network;
                                                    });
   icrc99_cast_status: (items: vec nat, _account: opt Account) ->
    (vec opt CastStateShared);
   /// Get remote addresses (e.g., Solana mint addresses) for IC token IDs
   /// This is a query function for efficient lookups without inter-canister calls
   /// Returns complete RemoteAddressInfo including derivation paths
   icrc99_get_remote_addresses: (tokenIds: vec nat) ->
    (vec opt RemoteAddressInfo) query;
   icrc99_native_chain: () -> (RemoteContractPointer) query;
   icrc99_remote_owner_of: (items: vec nat) -> (vec opt RemoteOwner) query;
   icrc99_request_remote_owner_status: (items: vec RequestRemoteOwnerRequest,
    account: opt Account) -> (vec opt RemoteOwnerResult);
   icrcX_burn: (tokens: BurnNFTRequest) -> (BurnNFTBatchResponse);
   /// Query if a principal is an authorized minter
   is_minter: ("principal": principal) -> (bool) query;
   mint_ck_nft: (token: MintNFTArgs) -> (SetNFTResult,
    opt ApproveTokenResult);
   /// Set or remove a principal as an authorized minter
   /// ONLY works for IC-native canisters (nativeChain.network = IC)
   /// Only callable by the owner
   set_minter: (minter: principal, action: variant {
                                             Add;
                                             Remove;
                                           }) -> (Result_1);
   update_cast_status: (cast_id: nat, status: CastStatus) -> (Result);
   /// Update the remote address for an NFT (called by orchestrator after cast completes or burn back to IC)
   /// Includes network, derivation path, optional account that controls approval address, and optional alternative address
   update_nft_remote_address: (tokenId: nat, remoteAddress: text, network:
    Network, derivationPath: blob, atRestAccount: opt Account__1, altAddress:
    opt text) -> (variant {
                    err: text;
                    ok;
                  });
 };
type BurnNFTResult = 
 variant {
   Err: BurnNFTError;
   Ok: nat;
 };
type BurnNFTRequest = 
 record {
   created_at_time: opt nat64;
   memo: opt blob;
   tokens: vec nat;
 };
type BurnNFTItemResponse = 
 record {
   result: BurnNFTResult;
   token_id: nat;
 };
type BurnNFTError = 
 variant {
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InvalidBurn;
   NonExistingTokenId;
 };
type BurnNFTBatchResponse = 
 variant {
   Err: BurnNFTBatchError;
   Ok: vec BurnNFTItemResponse;
 };
type BurnNFTBatchError = 
 variant {
   CreatedInFuture: record {ledger_time: nat64;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   TooOld;
   Unauthorized;
 };
type BlockType = 
 record {
   block_type: text;
   url: text;
 };
type BalanceOfResponse = vec nat;
type BalanceOfRequest = vec Account__1;
type ArgList__1 = 
 record {
   allow_transfers: opt bool;
   burn_account: opt Account;
   default_take_value: opt nat;
   deployer: principal;
   description: opt text;
   logo: opt text;
   max_memo_size: opt nat;
   max_query_batch_size: opt nat;
   max_take_value: opt nat;
   max_update_batch_size: opt nat;
   name: opt text;
   permitted_drift: opt nat;
   supply_cap: opt nat;
   supported_standards: opt SupportedStandards;
   symbol: opt text;
   tx_window: opt nat;
 };
type ArgList = 
 record {
   collection_approval_requires_token: opt bool;
   deployer: principal;
   max_approvals: opt nat;
   max_approvals_per_token_or_collection: opt nat;
   max_revoke_approvals: opt nat;
   settle_to_approvals: opt nat;
 };
type ArchivedTransactionResponse = 
 record {
   args: vec TransactionRange;
   callback: GetTransactionsFn;
 };
type ApproveTokenResult = 
 variant {
   Err: ApproveTokenError;
   Ok: nat;
 };
type ApproveTokenError = 
 variant {
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InvalidSpender;
   NonExistingTokenId;
   TooOld;
   Unauthorized;
 };
type ApproveTokenArg = 
 record {
   approval_info: ApprovalInfo;
   token_id: nat;
 };
type ApproveCollectionResult = 
 variant {
   Err: ApproveCollectionError;
   Ok: nat;
 };
type ApproveCollectionError = 
 variant {
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InvalidSpender;
   TooOld;
 };
type ApproveCollectionArg = record {approval_info: ApprovalInfo;};
type ApprovalInfo = 
 record {
   created_at_time: opt nat64;
   expires_at: opt nat64;
   from_subaccount: opt blob;
   memo: opt blob;
   spender: Account;
 };
type Account__1 = 
 record {
   owner: principal;
   subaccount: opt blob;
 };
type Account = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
service : (_args: opt
                   record {
                     defaults:
                      record {
                        description: opt text;
                        logo: opt text;
                        name: opt text;
                        symbol: opt text;
                      };
                     icrc37args: InitArgs;
                     icrc3args: opt InitArgs__1;
                     icrc7args: InitArgs__2;
                     icrc99args: InitArgs__3;
                   }) -> CKNFTActor
